0928 수요일
<출석체크>
09:10 문호준, 박근태, 박세웅(지각), 이용수, 정민경(결석), 홍승기(오후)

<공지사항>

<학습목표>
//단축키 ctrl shift o
       해당 클래스외부에서 뭔가 가져다 쓰려면 패키지를 import해줘야되는데 자동import 기능

- 상속, 인터페이스 복습
	상속 : extends 문법으로 코드의 중복을 막기위해서
	     부모클래스에 있는 변수와 메소드를 물려받는 기능
	extends(상속) 와 implements(구현)의 차이
		extends는 '존재' 'be'의 그룹화 목적. 1개의 부모로부터만 상속받을 수 있다.
		implements는 '기능의 강제'의 목적.  여러개의 인터페이스를 구현할 수 있다.
	어떤것을 상속받도록 개발해야할까?  인터페이스의 구현으로 개발해야할까?  
	사람마다 관점의 차이로 개발방법이 달라질수 있다.  
		상위그룹에 공통적인 특성들을 묶어서 하위에서 상속받도록 할건지
		반드시 오버라이딩으로 구현해야할 함수들을 미리 약속해두고 강제할건지
- 제네릭
	<데이터타입> 문법을 통해서 특정자료형을 일반화된 자료형으로 바꾸는 기능
	목적 : 정의시에 결정되던 데이터타입을 인스턴스 생성시 결정되도록 하기위해서
	왜 그렇게 하지?   데이터타입별로 정의해야하는 비효율을 없애주기 때문
	           런타임에 잘못된 타입이 들어올 수 있는것을 컴파일 단계에서 방지
			   타입캐스팅, 타입검사에 들어가는 노력을 줄여준다.
- 컬렉션프레임워크
	> 자바가 미리 만들어놓은 자료구조
	대표적인 3개 : 셋, 맵 리스트       인터페이스.
	- Set : 집합. 구현체로 HashSet이 대표적. 중복을 허락하지 않고, 자료의 순서가 없다.
	        데이터삽입 : 셋.add(값)
	- Map : 키, 밸류 의 쌍.    
	        데이터삽입 : 맵.put(키, 벨류)
	- List : 체인처럼 열거된 자료형.  크기가 고정인 배열의 단점을 보완한 자료구조.
	        구현체로 어레이리스트, 링크드리스트가 대표적.
			데이터삽입 : 리스트.add(값)
	- 큐, 스택 같은 자료구조도 자바가 미리 만들어놨다.
	//스택은 먼저 들어간게 제일 나중에 나온다.
		예) 프링글스, 접시쌓기
	//큐는 반대로 먼저들어간게 제일 먼저 나온다. 
		예) 선착순
- enum
	- Enumeration의 약자. 열거형.
	- 목적 : 우리만의 제한된 데이터타입을 가지기 위해서
	- 정의문법 : enum 이름 { 값, 값, 값}
		예) enum Rainbow {RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET}
	- 호출문법 : 이름.값
		예) Rainbow.RED
	- 모든 Enum은 java.lang.Enum 클래스를 상속받는다. 그래서 그안의 메서드를 사요할수 있다.
	- 메소드 
	   values()  //모든 상수값들을 배열로 반환.       Rainbow[] arr = Rainbow.values();\
	   valueOf()	//상수값 반환.              Rainbow rb = Rainbow.valueOf("GREEN")
	클래스는 변수와 메소드의 집합.   변수만 있는 개념 클래스에 담았어야 했다.
    변수이긴 변수인데 값이 바뀌지않는 상수의 열거타입이다?  enum
	
	 
	
인터페이스에는 함수에대한 약속만 들어갈수있는거 아니다.
	변수를 넣으면 public static final로 선언한것과 같다.
	인터페이스는 반드시 구현해야될 '약속'    값을 변경할수 없으면서 모든 인터페이스의 구현체끼리 공유하는 변수
	해당 인터페이스의 구현체는 반드시 이 동일한 값을 가지고있어야 된다는 제약조건

- 파일 입출력
	CRUD(Create, Read, Update, Delete). 쓰고, 읽고, 수정하고, 지우고
	FileReader, FileWriter, BufferedFileReader
	프로그램이 종료되더라도 데이터를 영구적으로 남기고싶다면?   파일에 저장, DB에 저장.
	- 어떤 폴더의 파일의 이름을 일괄적으로 변경(앞에다가 수정_ 붙이기)  파일.rename 함수
	
	스트링(문자열)
	파일 객체
	인스턴스 생성
	조건문, 반복문
	경로

- 쓰레드(오후)
컴퓨터는 프로세스별로 자원을 할당해요.(운영체제는 프로세스별로 하드웨어의 자원을 할당해요)
프로세스는 자원을 분리해서 쓰지만, 쓰레드는 동일 프로세스내의 자원을 공유해서 쓴다.
단일 프로세스의 단점 : IO작업시 CPU가 놀고있다.
	단점을 극복하기위해 멀티 프로그래밍의 등장.
멀티 프로그래밍 : 목적은 CPU사용의 극대화
	단점 : CPU사용안할때 다른 프로세스가 놀고있음
	해결방안 : 퀀텀이라는 짧은 시간동안 돌려막기
	이것을 멀티태스킹이라고 한다.
멀티 태스킹 : 프로세스의 응답시간을 최소화 시키는 목적 = 마치 여러 프로세스가 동시에 실행되는것처럼 보임.
	단점 : 하나의 프로세스가 동시에 여러작업을 실행하지는 못함.
	//컨텍스트 스위칭, IO 작업은 무거운 작업. 작업의 양이 큰 작업. 
	    프로세스끼리 메모리 공유가 어려움
		하드웨어의 성능을 잘 활용하지 못함(듀얼 코어, 쿼드라 코어 등)
	해결방안 : 쓰레드
쓰레드 : 1개의 프로세스는 최소한 1개의 쓰레드를 가지고있다.  보통은 n개의 멀티쓰레드로 구현되었다.
      CPU의 실행단위.
	 장점 : 컨텍스트 스위칭이 가볍다, 같은 프로세스 내에서는 메모리 공유가 된다.
멀티 쓰레딩 : 하나의 프로세스가 동시에 여러 작업을 실행
	//진짜 멀티쓰레딩이 되려면 하드웨어적으로도 코어가 지원되어야되고, 소프트웨어적으로도 멀티쓰레딩 개발이 되었어야하고
멀티 프로세싱 : 2개이상의 프로세서나 코어를 활용하는 시스템


<자바에서 쓰레드를 구현하는 법>
1. Thread 클래스를 상속
2. Runnable 인터페이스를 구현

<실행>
인스턴스.start();

<대표적인 메소드>
sleep, start, join, run

<쓰레드의 상태>
 (시작, 실행, 정상종료, 비정상종료)


컴퓨터랑 가위바위보를 할거다. 목숨은 5개-> 3명
내턴이되면 5초간의 카운트다운 -> 2명
5초동안 아무것도 내지못하면 내 턴 종료(그 턴패배)
5승 먼저 한 사람이 승리 -> 1명


- 자바총복습
